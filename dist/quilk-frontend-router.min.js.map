{"version":3,"sources":["quilk-frontend-router.js"],"names":["QuilkFrontendRouter","routesObject","verbose","this","verbose_mode","path","trimEnd","String","window","location","pathname","let","key","Array","isArray","this$1","log","run_path_matchers","subkey","$","alert","run_attribute_matchers","prototype","msg","console","attributesObject","values","attr","value","constructors","length","run_attribute_constructors","valueArr","split","selector","i","slice","constructorsArr","start_instance","path_match","init","instances_run","indexOf","e","error","push","substring","compare","match","key_to_paths","forEach","k_path","key_parts","ret","seg","paths","pop","join","str","str2Trim"],"mappings":"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","file":"quilk-frontend-router.min.js","sourcesContent":["export default class QuilkFrontendRouter {\r\n\r\n  /**\r\n   * Loops over a routesObject provided calling any classes that match the current browser url\r\n   */\r\n  constructor (routesObject, verbose = false) {\r\n\r\n    this.verbose_mode = verbose\r\n\r\n    let path = this.trimEnd(String(window.location.pathname), '/')\r\n    for (let key in routesObject) {\r\n\r\n      if (Array.isArray(routesObject[key])) {\r\n        this.log('Simple numeric array path matching')\r\n        this.run_path_matchers(routesObject, path, key)\r\n      } else {\r\n        if (key === 'path') {\r\n          this.log('Key hit \"path\", passing \"path\" object to the routing matcher')\r\n          for (let subkey in routesObject[key]) {\r\n            this.run_path_matchers(routesObject[key], path, subkey)\r\n          }\r\n        } else if (key === 'attributes') {\r\n          // check we have jquery else alert an error\r\n          if (typeof window.$ === 'undefined') {\r\n            alert('To use attribute selection with the QuilkFrontendRouter please ensure you load in jquery to the window object.')\r\n          } else {\r\n            this.log('Key hit \"attributes\", passing \"attributes\" object to the routing matcher')\r\n            this.run_attribute_matchers(routesObject[key])\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  log (msg) {\r\n    if (this.verbose_mode === true) {\r\n      console.log('QuilkFrontendRouter message: ', msg)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Initialises classes based on the attributes given\r\n   *\r\n   * @param attributesObject\r\n   */\r\n  run_attribute_matchers (attributesObject) {\r\n    let $ = window.$\r\n\r\n    for (let key in attributesObject) {\r\n      let values = attributesObject[key]\r\n      let attr   = key\r\n\r\n      for (let value in values) {\r\n        let constructors = values[value]\r\n\r\n        if (value === '*') {\r\n          if ($('*[' + attr + ']').length > 0) {\r\n            this.log('Wildcard hit for attr \"' + attr + '\"')\r\n            this.run_attribute_constructors(constructors)\r\n          }\r\n        } else {\r\n          let valueArr = value.split(' ')\r\n\r\n          // run against classes\r\n          let selector = ''\r\n          switch (attr) {\r\n            case 'class' : {\r\n              for (let i = 0; i < valueArr.length; ++i) {\r\n                selector += '.' + valueArr[i] + ', '\r\n              }\r\n            }\r\n              break\r\n            case 'id' : {\r\n              for (let i = 0; i < valueArr.length; ++i) {\r\n                selector += '#' + valueArr[i] + ', '\r\n              }\r\n            }\r\n              break\r\n            default : {\r\n              for (let i = 0; i < valueArr.length; ++i) {\r\n                selector += '*[' + attr + '=' + valueArr[i] + '], '\r\n              }\r\n            }\r\n          }\r\n          selector = selector.slice(0, -2)\r\n          if ($(selector).length > 0) {\r\n            this.log('Attr + val hit: ' + selector)\r\n            this.run_attribute_constructors(constructors)\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Pass an numeric array of class to initialize\r\n   *\r\n   * @param constructorsArr\r\n   */\r\n  run_attribute_constructors (constructorsArr) {\r\n    for (let i = 0; i < constructorsArr.length; ++i) {\r\n      this.start_instance(constructorsArr[i])\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Runs checks against the key and the path\r\n   *\r\n   * @param routesObject\r\n   * @param path\r\n   * @param key\r\n   */\r\n  run_path_matchers (routesObject, path, key) {\r\n    if (this.path_match(path, key)) {\r\n      for (let i = 0; i < routesObject[key].length; ++i) {\r\n        this.start_instance(routesObject[key][i])\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calls new on a class\r\n   *\r\n   * @param init\r\n   */\r\n  start_instance (init) {\r\n    if (!this.instances_run) this.instances_run = []\r\n\r\n    if (this.instances_run.indexOf(init) === -1) {\r\n      try {\r\n        new init\r\n      } catch (e) {\r\n        console.error(e)\r\n      }\r\n      this.instances_run.push(init)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns true if the provided path matches the key\r\n   *\r\n   * @param path\r\n   * @param key\r\n   * @returns {boolean}\r\n   */\r\n  path_match (path, key) {\r\n\r\n    //handle trailing wildcards\r\n    if (key.slice(-1) === '*') {\r\n\r\n      key = key.substring(0, key.length - 1)\r\n\r\n      if (key === '/' && path !== '/' && path.split('/').length === 2) return true\r\n\r\n      if (this.compare(path, key)) return true\r\n      else return ( path.indexOf(key) === 0 )\r\n    }\r\n\r\n    //handle std route\r\n    if (key.indexOf('(') === -1) return this.compare(path, key)\r\n\r\n    //handle key with params eg ()\r\n    let match = false\r\n    this.key_to_paths(key).forEach((k_path) => {\r\n      if (this.compare(path, k_path)) match = true\r\n    })\r\n\r\n    return match\r\n  }\r\n\r\n  /**\r\n   * Takes a key from the constants and returns a numeric array of all possible paths\r\n   *\r\n   * @param key\r\n   * @returns {[*]}\r\n   */\r\n  key_to_paths (key) {\r\n    let key_parts = key.split('(')\r\n    let ret       = [this.trimEnd(key_parts[0], '/')]\r\n    //walk over each provided segment in the () | separated params, ensuring the last ) char is stripped\r\n    key_parts[1].slice(0, -1).split('|').forEach((seg) => {\r\n      ret.push(this.trimEnd(key_parts[0] + seg, '/'))\r\n    })\r\n    return ret\r\n  }\r\n\r\n  /**\r\n   * Compares a given key and path. If the kay contains a : separated param this is removed first from the key and path before comparison.\r\n   *\r\n   * @param path\r\n   * @param key\r\n   */\r\n  compare (path, key) {\r\n\r\n    key = this.trimEnd(key, '/')\r\n    if (key.indexOf(':') === -1) return (path === key)\r\n\r\n    //we have found a key with a param, strip param from path and key, then re-compared\r\n    key = this.trimEnd(key.split(':')[0], '/')\r\n\r\n    //strip the trialing url segment\r\n    let paths = path.split('/')\r\n    paths.pop()\r\n\r\n    path = this.trimEnd(paths.join('/'), '/')\r\n\r\n    return (path === key)\r\n  }\r\n\r\n  /**\r\n   * Trims the end of the string if matched to the str2trim. Clone of the lodash trimEnd function\r\n   *\r\n   * @param str\r\n   * @param str2Trim\r\n   * @returns {string}\r\n   */\r\n  trimEnd (str, str2Trim) {\r\n    if (str.substring(str.length - str2Trim.length, str.length) === str2Trim)\r\n      return str.substring(0, str.length - str2Trim.length)\r\n    return str\r\n  }\r\n}"]}